<?php

declare(strict_types=1);

/*
 * @copyright   2018 Mautic Inc. All rights reserved
 * @author      Mautic, Inc. Jan Kozak <galvani78@gmail.com>
 *
 * @link        http://mautic.com
 * @created     19.9.18
 * @license     GNU/GPLv3 http://www.gnu.org/licenses/gpl-3.0.html
 */

namespace MauticPlugin\MauticVtigerCrmBundle\Vtiger\Model\Validator;

use MauticPlugin\MauticVtigerCrmBundle\Exceptions\InvalidObjectException;
use MauticPlugin\MauticVtigerCrmBundle\Exceptions\Validation\InvalidObject;
use MauticPlugin\MauticVtigerCrmBundle\Vtiger\Model\BaseModel;
use MauticPlugin\MauticVtigerCrmBundle\Vtiger\Model\ModuleFieldInfo;
use MauticPlugin\MauticVtigerCrmBundle\Vtiger\Repository\BaseRepository;
use MauticPlugin\MauticVtigerCrmBundle\Vtiger\Repository\UserRepository;
use Symfony\Component\Validator\Constraints\Choice;
use Symfony\Component\Validator\Constraints\Email;
use Symfony\Component\Validator\Constraints\NotNull;
use Symfony\Component\Validator\Validation;

trait ObjectValidatorTrait
{
    /**
     * @var BaseRepository
     */
    protected $baseRepository;

    /**
     * @var UserRepository
     */
    private $userRepository;

    /**
     * @var \Symfony\Component\Validator\ValidatorInterface
     */
    private $validator;

    /**
     * @var array
     */
    private $existingUsersIds = [];

    /**
     * ObjectValidatorTrait constructor.
     *
     * @param BaseRepository      $objectRepository
     * @param UserRepository|null $userRepository
     */
    public function __construct(BaseRepository $baseRepository, ?UserRepository $userRepository = null)
    {
        $this->baseRepository   = $baseRepository;
        $this->userRepository   = $userRepository;
        $this->validator        = Validation::createValidator();    // Use symfony validator TODO inject
    }

    /**
     * @param BaseModel $object
     *
     * @throws InvalidObject
     * @throws InvalidObjectException
     */
    public function validate(BaseModel $baseModel): void
    {
        $this->validateObject($baseModel);
    }

    /**
     * @param BaseModel $object
     *
     * @throws InvalidObject
     * @throws InvalidObjectException
     */
    protected function validateObject(BaseModel $baseModel): void
    {
        if (!$baseModel instanceof BaseRepository::$moduleClassMapping[$this->baseRepository->getModuleFromRepositoryName()]) {
            throw new \InvalidArgumentException('This validator supports only object of type '
                .$this->baseRepository->getModuleFromRepositoryName());
        }

        $description = $this->baseRepository->describe()->getFields();

        foreach ($baseModel->dehydrate() as $fieldName => $fieldValue) {
            $fieldDescription = $description[$fieldName];
            $this->validateField($fieldDescription, $fieldValue);
        }
    }

    /**
     * @param ModuleFieldInfo $fieldInfo
     * @param                 $fieldValue
     *
     * @throws InvalidObject
     * @throws InvalidObjectException
     */
    private function validateField(ModuleFieldInfo $moduleFieldInfo, $fieldValue): void
    {
        $validators = [];
        if (!$moduleFieldInfo->isNullable() && $moduleFieldInfo->isMandatory() && null === $fieldValue) {
            $validators[] = new NotNull();
        }

        //  Validate by data type
        $validators = array_merge($validators, $this->getValidatorsForType($moduleFieldInfo->getTypeObject(), $fieldValue));

        if (!count($validators)) {
            return;
        }

        //  Validate for required fields
        $violations = $this->validator->validate($fieldValue, $validators);
        if (!count($violations)) {
            return;
        }

        throw new InvalidObject($violations, $moduleFieldInfo, $fieldValue);
    }

    /**
     * @param $typeObject
     * @param $fieldValue
     *
     * @return array
     *
     * @throws InvalidObjectException
     */
    private function getValidatorsForType($typeObject, $fieldValue): array
    {
        $validators = [];

        switch ($typeObject->name) {
            case 'autogenerated':
            case 'string':
                break;
            case 'email':
                $validators[] = new Email();

                break;
            case 'owner':
                if (!count($this->existingUsersIds) || true) {
                    $users                  = $this->userRepository->findBy();
                    $this->existingUsersIds = array_map(function ($o) { return $o->id; }, $users);
                }

                $validators[] = new Choice(['choices' => $this->existingUsersIds]);

                break;
            default:
                throw new InvalidObjectException('Unknown field type '.print_r((array) $typeObject, true));
        }

        return $validators;
    }
}
